第14章 类型信息

    14.1 为什么需要RTTI
        1. RTTI（Run-Time Type Identification），通过运行时类型信息程序能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际派生类型。
        2. 类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM的一部分。
        3. 为使用累而进行的准备工作：
            1). 加载，这是由类加载器执行的。该步骤将查找字节码，并从这些字节码中创建一个Class对象。
            2). 链接，在链接阶段将验证累中的字节码，为静态域分配存储空间，如果必须的话，将解析这个类创建的
                对其他类的所有引用。
            3). 初始化，如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。

    14.7 动态代理
        1. Java适配器模式、代理模式及动态代理
            适配器模式主要解决的是接口的兼容性问题，，比如有A、B两个接口，在客户端，应用程序主要使用的是A接口提供的服务，
            在使用的过程中，发现B接口和A接口提供的服务具有相似性，因此我想在不改动我应用程序的基础上也能获取B接口的服务。
            怎么办呢，如果对B接口（及实现它的子类）进行重构，工作量太大，那么就引入一个适配器C，C实现A接口，C的内部包含
            B接口的实例，这样就可以通过包含的B接口实例来完成A接口所需提供的功能。注意，适配器模式下，C中可能不需要B接口
            提供的所有的服务，部分就可以了。

            代理模式，主要是针对不方便把接口的实现暴露给客户端，或者需要除了原始服务之外，还要添加一些额外的功能，如添加
            日志、缓存等，从而引入一个中间的代理，由代理直接与客户端对话。代理内部同样包含被代理接口的实例，但是一般代理
            提供的服务包含被代理接口所提供的所有服务。

            动态代理，利用Java反射机制，可以进一步实现动态代理。静态代理可以通过添加附加的代理类来实现，当接口数量较多时
            编码量会比较大，并且由于增加了代理类，导致系统比较臃肿。